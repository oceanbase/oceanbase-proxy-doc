# 高可用机制

高可用是分布式系统的一个重要特点。本文主要介绍 ODP 的高可用机制。

首先，ODP 足够轻量，本身服务可以在 1s 内拉起。另外，obproxyd.sh 脚本也会对 ODP 进行端口探测，保证服务的可用。

从业务效果看，ODP 需要保证不路由到有问题的机器从而保证服务正常。但实际中会有一些限制，从 ODP 本身视角看，数据库异常主要分为两部分：

1. 查询内部表获取数据库的状态信息，如 server、zone 等情况

2. 从 OBServer 的返回报文中获取异常信息，如特殊错误码标识状态信息

## 黑名单

ODP 从 `__all_virtual_zone_stat` 和 `__all_virtual_server_stat` 中获取 zone 和 server 的状态信息，确认 server 的升级、合并、ACTIVE/INACTIVE 等状态，

* 如果机器在升级中或者状态为 INACITVE，则直接加入到黑名单中，后续请求不会发往该机器；

* 如果机器处于合并状态，将路由到合并状态机器的算法放到最后，尽量避免请求发往合并状态的机器。

* 如果 RS 节点发现机器不可用，会在 `__all_server` 表中做标记，ODP 可以在 20s 左右的时间内感知到，请求便不会发往该机器。例子如下，搜索关键字dead_congested

## 活不可用名单

对于不在黑名单的机器，ODP 根据机器返回的错误确定是否将该机器加入到活不可用名单。

1. 如果 OBServer 返回系统错误，比如系统内存超限、数据包校验出错、正在初始化、正在退出、server response 超时、clinet connect 超时等，将该机器的活不可用计数加 1。

2. 如果机器在 N 秒内有 M 次活不可用的失败计数，则将该机器加入活不可用黑名单。

> **说明**
>
> 通过命令 `show proxycongestion [all] [clustername]` 可以查看集群的黑名单信息，其中 `dead_congested` 和 `alive_congested` 两个字段分别对应黑名单和活不可用名单。

## 洗白策略

对于黑名单，根据内部表返回信息进行洗白即可。

对于活不可用名单，如果机器被加入活不可用黑名单，在 `congestion_retry_interval` 时间不会转发任何请求给该机器，在 `retry_interval` 时间后发起重试，在 `min_keep_congestion_interval` 时间里不能被洗白。

## 重试策略

![执行逻辑](6.high-availability-01)

上图所示是 ODP 的执行逻辑，由上图可知，重试有两个发生时间：

* 路由后判断选择的机器是否可用：在向机器建立连接前就判断路由算法选择的机器是否可用，如果不可用重新选择机器。

* 机器返回结果后根据错误信息确定是否可以重试：如果机器返回特殊的错误报文，如资源限制、连接数限制、内存超限、正在初始化、正在退出等指定错误码。

> **说明**
>
> 对于重试，错误码包含很多细节。

## Leader 切换

ODP 不会主动感知 Leader 切换动作，只可在 SQL 执行后根据返回信息获得 Leader 切换信息。

举例说明：

高可用测试中，t1 表的 Leader 在 server1 上，使用 `kill -19` 命令“杀”掉 server1 上的进程。过 10min 后访问 t1 表，发现触发了客户端的 5s 超时，业务报错。

原因：之前访问 t1 表时，ODP 的 Location Cache 中保存了 t1 表的 Leader 在 server1 上这一信息。10min 后访问，RS 中内部表未更新，仍使用该信息，将 SQL 发送到 server1，但此时 server1 无响应，过了 5s 后 JDBC 超时，将连接关掉，ODP 也不会触发 Location Cache 刷新。
