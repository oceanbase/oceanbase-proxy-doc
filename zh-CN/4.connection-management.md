# 连接管理

OBProxy 为用户提供了数据库接入和路由功能，用户连接 OBProxy 就可以正常使用 OceanBase 数据库。用户在使用数据库功能时，OBProxy 和 OBServer 进行交互，且交互流程对用户透明，连接管理就是该交互过程中的关键点之一。

OBProxy 的连接管理有三个特性：

1. 代理特性：OBProxy 既是客户端，也是服务端，还需要保证交互行为符合 MySQL 协议规范。
   <!-- 不需要符合 Oracle 协议规范么 -->
2. 功能特性：OBProxy 实现了很多的连接功能特性，如访问不同集群、不同租户，再如支持主备库、分布式下的 PS 功能，以及兼容 kill、show processlist 等命令。

3. 高可用特性：OBProxy 可以处理超时、机器状态变化、网络状态变化等问题，屏蔽后端异常，让用户无感知。

接下来我们按使用 OBProxy 的操作步骤一步一步来讲解连接管理内容。

## 第一步：用户登录

### 登录信息

在登录 OBProxy 时需要填写数据库 IP 和 PORT、用户名、密码等信息。对于用户名，OBServer 的格式为 `user_name@tenant_name`，同时因为 OBProxy 可以代理不同的集群，所以格式又变为 `user_name@tenant_name#cluster_name`，字段含义如下：

* `user_name`：登录的用户名，密码保存在 OBServer 中，OBProxy 只做登录报文转发不做密码校验。

* `tenant_name`：OBServer 是多租户架构，tenant_name 表示访问的租户名。

* `cluster_name`：集群名，OBProxy 支持访问多个集群，不同集群通过 cluster_name 区分。

有了这些信息，我们就可以通过 JDBC 驱动、MySQL 命令行、Navicat 等工具连接 OBProxy 访问数据库了。

那么用户登录时 OBProxy 如何找到对应的机器呢？这就要依赖 OCP 系统（通过 obproxy_config_server_url 配置项指定 OCP 的 url 地址访问），OCP 会保存集群名和集群的机器列表，OBProxy 通过访问 OCP 获取这些信息，整个流程如下图。
<!-- 单纯的使用 OBD 部署集群，之后使用 ODP 连接的情况也是这样么，应该不是吧 -->

![流程图]()

### 登录认证

找到机器后就可以登录认证了，关键信息是用户名和密码，MySQL 协议中（官方图片中展示了 Handshake 相关报文，实际流程中第2步结束后服务端需要回复一个 OK 或者 Error 报文给客户端）的交互流程如下图。

![交互流程]()

OBProxy 作为代理组件，要兼容 MySQL 行为，会有更多步骤。此处以 Java 程序连接数据库为例说明整个流程，在 Java 程序中，登录代码只有一行：

```java
conn = (Connection) DriverManager.getConnection(URL, USER_NAME, PASSWORD);
```

但背后的原理比较复杂，如下图所示：

![流程图]()

在完成协议的登录步骤（第 8 步）后，MySQL 协议层的登录交互就结束了，但 JDBC 会发送一些初始化 SQL，也属于登录过程一部分，图中第 9 步表示该过程。初始化 SQL 有多条，内容如下：

```sql
set autocommit=1, sql_mode = concat(@@sql_mode,',STRICT_TRANS_TABLES')
set names utf8
SELECT @@max_allowed_packet,@@system_time_zone,@@time_zone,@@auto_increment_increment,@@tx_isolation AS tx_isolation,@@session.tx_read_only AS tx_read_only
select @@version_comment, @@version limit 1
```

上面 SQL 执行完成后，Java 程序就可以发送业务 SQL 了。

### 常见登录问题

在明白 OBProxy 的登录原理之后就可以在登录失败时快速地定位和解决问题。常见的问题及原因如下：

* 用户名或密码错误，可以通过直连 OBServer 确定。

* OCP 故障，无法拉取集群机器列表，可以通过 curl 命令访问 OCP 的 url 确定。

* OBServer 执行获取机器列表或初始化 SQL 失败，需要日志排查定位。

* 超过最大连接数设置或不在白名单中，后文将为你详细解读。
<!-- 后文是哪里，需要重点注意 -->
对于上述问题，你可以通过查看 obproxy_error.log 方式解决。详细情况请参考 [监控日志说明]()。

## 第二步：连接管理

登录成功后，客户端到 OBProxy、OBProxy 到 OBServer 之间的网络连接便建立了起来，此时 OBProxy 只是和其中一台 OBServer 建立了连接。随着 SQL 请求的到来，如果路由到新的 OBServer，OBProxy 会和新的 OBServer 建立连接。在此过程中涉及连接的映射关系、状态同步和连接功能特性。

### 连接的映射关系

连接映射主要讲客户端连接和服务端连接之间的关系，首先从一个客户端连接说起。当客户端和 OBProxy 建立一个连接后，OBProxy 会和后面 N 个 OBServer 建立连接，整个关系如下图所示：

![映射图]()

从图中可以看到，OBProxy 按需和两台 OBServer 建立了连接，这两个连接只属于这一个客户端连接，不会被其他客户端连接复用。连接映射的关键点就是需要用 ID 标识出每一个连接并记录 ID 之间的映射关系，我们可以将上图抽象成模型：

App<-----[proxy_sessid1]---->OBProxy<---[server_sessid1]----->OBServer1
                                              <---[server_sessid3]----->OBServer3
<!-- 没有看懂这个抽象模型的意思 -->
这样就可以用 proxy_sessid 唯一标识 App 和 OBProxy 之间的连接，用 server_sessid 唯一标识 OBProxy 和 OBServer 之间的连接。当出现 SQL 执行错误、执行慢等情况时，OBProxy 会将映射关系打印到日志中，这样就可以将 App 和 OBServer 关联起来，进行全链路问题定位。

### 状态同步

一个客户端连接对应多个服务端连接，要保证执行结果的正确性，就要求多个服务端连接的 session 状态是一致的。

接下来举例说明 session 状态不同步将会导致什么问题，假设用户执行以下 SQL 命令：

```sql
set autocommit=1;
insert into t1 values(1);
insert into t2 values(2);
```

执行过程如下：

* `set autocommit=0` 发给 OBServer1

* `insert into t1 values(1)` 发给 OBServer1

* 进行连接切换，`insert into t2 values(2)` 发给 OBServer2

![执行过程]()

对于第三条 SQL，OBProxy 和 OBServer2 的连接并未同步连接状态 `autocommit=1`，这样就可能导致第三条语句 `insert into t2` 并未提交事务。

正确的步骤是 OBProxy 在给 OBServer2 发送 INSERT SQL 前，先同步 autocommit 变量的值。OBProxy 通过版本号机制解决了状态同步的问题，实现了 database、session variables、last_insert_id、ps prepare 语句的状态同步，保证功能的正确性。

### 连接功能特性

和单机数据库不同，OBProxy 改变了连接的映射关系为 M:N，因此有些连接功能需要做额外处理。

举例说明：用户通过 `show processlist` 查看连接数，此时希望看到的是客户端和 OBProxy 之间的连接数，而不是 OBProxy 和 OBServer 之间的连接数。

下面我们对常见的连接功能展开详细介绍。

* 连接粘性

  OBProxy 还未实现所有功能的状态同步，如事务状态、临时表状态、cursor 状态等。对于这些功能，OBProxy 只会将后续请求都发往状态开始的节点，这样就不需要进行状态同步，而缺点是无法充分发挥分布式系统的优势。因此，OBProxy 将根据功能重要程度，逐步支持相关功能的分布式化。

* show processlist 和 kill 命令配套使用

  show processlist 用于展示客户端和服务端之间的连接，对于 OBProxy 来说，show processlist 只展示客户端和 OBProxy 之间的连接，不展示 OBProxy 和 OBServer 之间的连接。
  
  kill 命令用于杀死一个客户端连接，客户端连接关闭后，OBProxy 也会关闭对应的服务端连接。对于 OBProxy 的 kill 命令，需要先获取对应的 ID（使用 show processlist 命令即可获取 ID）。

* 负载均衡影响
  
  因为 OBProxy 对 show processlist 和 kill 命令做了处理，所以 show processlist 和 kill 命令只有都发往同一台 OBProxy 才能正常工作。在公有云等环境，OBProxy 前面有负载均衡，负载均衡后面挂在多个 OBProxy 上，此时，如果执行 show prcesslist 和 kill 命令是两个不同的连接，负载均衡组件可能将请求发往不同的 OBProxy，在这种情况下，建议不要使用相关命令。
