# TABLE_ENTRY_LOOKUP

本文介绍 TABLE_ENTRY_LOOKUP 诊断点的相关信息。

TABLE_ENTRY_LOOKUP 诊断点涉及的诊断信息如下图所示。

![](./420.table-entry-lookup-01)

TABLE_ENTRY_LOOKUP 诊断点的诊断信息具体介绍如下。

* table：表示执行的 SQL 语句涉及到的表名，值为 `__all_dummy` 时可能出现路由不准的情况，将会走路由策略路由

<!-- * 无 table_id 的介绍 -->

* part_num：表示分区数量，值为 1 时表示为普通表，普通表不会有分区计算的诊断输出；值大于 1 表示为分区表，需要关注下一诊断点（PARTITION_ID_CALC_DONE 诊断点）是否出错

<!-- * table_type：介绍所涉及表的类型，为系统表、虚拟表、视图、用户表等等。 -->

* entry_state：表示 Routine Entry 的状态，有如下几种状态。您需排查其值是否为 DIRTY，其值为 DIRTY 时可能会导致路由不准。
  
  * BORN：函数/过程已经被声明，但尚未被执行
  
  * BUILDING：函数/过程的代码正在被编译或构建的过程中，尚未被分配内存空间和执行
  
  * AVAIL：函数/过程已经被声明、定义并且可供调用
  
  * DIRTY：函数/过程的代码或数据已经被修改，但尚未被保存或提交
  
  * UPDATING：函数/过程的代码或数据正在被修改中，即正在进行更新操作
  
  * DELETED：函数/过程已经被删除或移除

* entry_from_remote：为 true 时表示查到的信息直接来自 OBServer 节点，如果查到的信息不来自 OBServer 节点，有会出现 OBServer 远端已经修改了信息，但是还没有被 ODP 取回的情况，可能导致远程路由

* has_dup_replica：表示是否请求复制表，其值为 true 时表示请求复制表，此时读请求会随机发送到某个持有该分区的 Follow/Leader，写请求则发给 Leader

* is_lookup_succ：表示查询是否成功，若其值为 false 表示查询失败，失败则会走路由策略路由

若该诊断点无问题，根据是否为分区表，有如下两种情况。

* 若查询表为分区表，且分区键的类型支持分区计算，则可继续诊断 PARTITION_ID_CALC_DONE 诊断点，详细信息请参见 [PARTITION_ID_CALC_DONE](./430.partition-id-calc-done.md)。

* 若查询表为非分区表，或分区键的类型当前不支持分区计算，您可直接诊断 ROUTE_POLICY 诊断点，详细信息请参见 [ROUTE_POLICY](./500.route-policy.md)。
