# 使用示例

本文结合 MySQL 租户模式下不同示例介绍如何使用路由诊断功能。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <ul>
  <li>
  <p>各个诊断点的诊断信息可参见 <a href="300.diagnosis-point-troubleshooting/100.overview-of-diagnosis-point-troubleshooting.md">诊断点排查</a> 章节。</p>
  </li>
  <li>
  <p>本文示例中均已将 route_diagnosis_level 设置为 4。</p>
</main>

## 示例一：PS/PL 语句调用

当 PS 调用路由不准时，execute 实际执行的语句不方便寻找，您可查看对应诊断日志，通过诊断日志查看执行的相关语句。

```shell
[2023-09-19 18:48:49.079458] [106700][Y0-00007FD892AB64E0] [ROUTE]((*route_diagnosis=
Trans Current Query:"execute stmt"
Route Prompts
--------------
> ROUTE_INFO
  [INFO] Will do table partition location lookup to decide which OBServer to route to
> ROUTE_POLICY
  [INFO] Will route to table's partition leader replica(10.10.10.1:4001) using non route policy because query for STRONG read
Route Plan
--------------
> SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
> ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
> LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
  > TABLE_ENTRY_LOOKUP_DONE:{table:"t0", table_id:"500078", table_type:"USER TABLE", partition_num:64, entry_from_remote:false}
  > PARTITION_ID_CALC_START:{}
    > EXPR_PARSE:{col_val:"=88888888,=1111111"}
    > RESOLVE_EXPR:{part_range:"[88888888 ; 88888888]", sub_part_range:"[1111111 ; 1111111]"}
      > RESOLVE_TOKEN:{token_type:"TOKEN_INT_VAL", resolve:"BIGINT:88888888", token:"88888888"}
      > RESOLVE_TOKEN:{token_type:"TOKEN_INT_VAL", resolve:"BIGINT:1111111", token:"1111111"}
    > CALC_PARTITION_ID:{part_description:"partition by hash(INT<binary>) partitions 8 subpartition by hash(INT<binary>) partitions 8"}
  > PARTITION_ID_CALC_DONE:{partition_id:200073, level:2, partitions:"(p0sp7)", parse_sql:"prepare stmt from 'insert into t0 values(88888888,1111111,9999999)'"}
  > PARTITION_ENTRY_LOOKUP_DONE:{leader:"10.10.10.1:4001", entry_from_remote:false}
> ROUTE_POLICY:{chosen_route_type:"ROUTE_TYPE_LEADER"}
> CONGESTION_CONTROL:{svr_addr:"10.10.10.1:4001"}
```

从诊断点 PARTITION_ID_CALC_DONE 的诊断信息 parse_sql 中可以查到对应语句的相关输出。

## 示例二：分区表查询

### 未提供分区键值导致分区表路由不准

以 t0 为二级分区表，执行语句 `select * from t0 where c1=1` 路由不准为例，执行如下命令进行路由诊断。

```sql
obclient> EXPLAIN ROUTE select * from t0 where c1=1\G
```

输出如下所示。

```shell
Trans Current Query:"select * from t0 where c1=1"
Route Prompts
--------------
> ROUTE_INFO
  [INFO] Will do table partition location lookup to decide which OBServer to route to
> PARTITION_ID_CALC_DONE
  [WARN] Fail to use partition key value to calculate sub part idx
Route Plan
--------------
> SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
> ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
> LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
  > TABLE_ENTRY_LOOKUP_DONE:{table:"t0", table_id:"500078", table_type:"USER TABLE", partition_num:64, entry_from_remote:false}
  > PARTITION_ID_CALC_START:{}
  > EXPR_PARSE:{col_val:"c1=1"}
  > RESOLVE_EXPR:{part_range:"[1 ; 1]", sub_part_range:"(MIN ; MAX)always true"}
    > RESOLVE_TOKEN:{token_type:"TOKEN_INT_VAL", resolve:"BIGINT:1", token:"1"}
  > CALC_PARTITION_ID:{error:-4002, part_description:"partition by hash(INT<binary>) partitions 8 subpartition by hash(INT<binary>) partitions 8"}
> PARTITION_ID_CALC_DONE:{error:-4002, partition_id:-1, level:2, partitions:"(p1sp-1)"}
```

根据诊断结果进行分析。

1. 查看路由提示 `PARTITION_ID_CALC_DONE [WARN] Fail to use partition key value to calculate sub part idx` 表示计算二级分区位置失败。

2. 查看路由计划中 PARTITION_ID_CALC_DONE 附近数据是否有相关信息。

3. 路由计划中诊断点 `RESOLVE_EXPR:{part_range:"[1 ; 1]", sub_part_range:"(MIN ; MAX)always true"}` 表示二级分区的范围为 `MIN:MAX`，所以无法确定二级分区具体位置。

4. 反推语句 `Trans Current Query:"select * from t0 where c1=1"` 没有提供二级分区键值。

### 使用不支持的表达式计算分区键值导致分区表路由不准

以 t0 为分区表，执行语句 `select * from t0 where c1=abs(-100.123);` 路由不准为例，查看对应诊断日志内容如下。

```shell
[2023-09-19 19:43:11.029616] [106683][Y0-00007FD890E544E0] [ROUTE]((*route_diagnosis=
Trans Current Query:"select * from t0 where c1=abs(-100.123)"
Route Prompts
--------------
> ROUTE_INFO
  [INFO] Will do table partition location lookup to decide which OBServer to route to
> RESOLVE_TOKEN
  [WARN] Not support to resolve expr func(abs)
Route Plan
--------------
> SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
> ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
> LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
  > TABLE_ENTRY_LOOKUP_DONE:{table:"t0", table_id:"500078", table_type:"USER TABLE", partition_num:64, entry_from_remote:false}
  > PARTITION_ID_CALC_START:{}
    > EXPR_PARSE:{col_val:"c1=abs"}
    > RESOLVE_EXPR:{error:-5055, part_range:"(MIN ; MAX)always true", sub_part_range:"(MIN ; MAX)always true"}
      > RESOLVE_TOKEN:{error:-5055, token_type:"TOKEN_FUNC", token:"abs"}
    > PARTITION_ID_CALC_DONE:{error:-5055, partition_id:-1, level:2, partitions:"(p-1sp-1)"}
> ROUTE_INFO:{route_info_type:"USE_CACHED_SESSION", svr_addr:"10.10.10.1:4001"}
> CONGESTION_CONTROL:{svr_addr:"10.10.10.1:4001"}
> HANDLE_RESPONSE:{is_parititon_hit:"true", send_action:"SERVER_SEND_REQUEST", state:"CMD_COMPLETE"}
)
```

诊断结果中 `RESOLVE_TOKEN [WARN] Not support to resolve expr func(abs)` 表示不支持解析 abs 表达式。因此可知该语句无法解析表达式，从而无法计算出正确的分区键值，所以无法路由准确。

## 路由策略路由

以执行 `SELECT 100 - max(round(total / mem_limit * 100)) FROM oceanbase.gv$ob_memstore` 命令路由目标不符合预期为例，执行如下命令进行路由诊断。

```sql
obclient> EXPLAIN ROUTE SELECT 100 - max(round(total / mem_limit * 100)) FROM oceanbase.gv$ob_memstore\G
```

输出如下所示。

```shell
*************************** 1. row ***************************
Route Plan:
Trans Current Query:"EXPLAIN ROUTE SELECT 100 - max(round(total / mem_limit * 100)) FROM oceanbase.gv$ob_memstore"
Route Prompts
-----------------
> ROUTE_INFO
  [INFO] Will do table partition location lookup to decide which OBServer to route to
> TABLE_ENTRY_LOOKUP_DONE
  [INFO] Non-partition table will be routed by ROUTE_POLICY
> ROUTE_POLICY
  [INFO] All OBServers treated as the SAME_IDC with OBProxy because 'proxy_idc_name' is not configured
  [INFO] Will route to routing type(NONPARTITION_UNMERGE_LOCAL) matched replica(10.10.10.1:4001) using default route policy MERGE_IDC_ORDER because query for STRONG read
```

根据路由提示：`[INFO] All OBServers treated as the SAME_IDC with OBProxy because 'proxy_idc_name' is not configured` 可知没有配置 proxy_idc_name，ODP 将所有 OBServer 节点视为 SAME_IDC，LDC 路由将失效。
