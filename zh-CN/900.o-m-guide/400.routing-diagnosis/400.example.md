# 使用示例

本文结合 MySQL 租户模式下不同示例介绍如何使用路由诊断功能。
<!-- 是否要补充一下各个示例的讲解 -->
<main id="notice" type='explain'>
  <h4>说明</h4>
  <ul>
  <li>
  <p>各个诊断点的诊断信息可参见 <a href="300.diagnosis-point-troubleshooting/100.overview-of-diagnosis-point-troubleshooting.md">诊断点排查</a> 章节。</p>
  </li>
  <li>
  <p>本文示例中均已将 route_diagnosis_level 设置为 4。</p>
</main>

## 示例一：路由策略路由

1. 准备

   ```sql
   obclient> alter proxyconfig set enable_cached_server = false;
   obclient> create table t(c1 int);
   ```

2. 执行 explain route

   ```sql
   obclient> set @@ob_read_consistency=WEAK;
   obclient> explain route select * from test.t where c1=12312\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route select * from test.t where c1=12312"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to partition server or ldc
   > TABLE_ENTRY_LOOKUP_DONE
     [INFO] Non partition table will be routed by LDC routing
     [INFO] Entry maybe expired since it got from proxy local cache
   > LDC_ROUTE
     [INFO] The priority of region and idc going to be invalid. All OBServer treated as to be the SAME_IDC with OBProxy
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t"}
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"t", table_id:1099511677781, table_type:"USER TABLE", entry_from_remote:false}
   > LDC_ROUTE:{replica:"10.10.10.1:50111", idc_type:"SAME_IDC", zone_type:"ReadWrite", role:"FOLLOWER", type:"FULL", is_partition_server:true, chosen_route_type:"ROUTE_TYPE_PARTITION_UNMERGE_LOCAL", route_policy:"MERGE_IDC_ORDER", trans_consistency:"WEAK", session_consistency:"WEAK"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.1:50111"}
   
   1 row in set (0.00 sec)
   ```

## 示例二：分区表路由

### 普通语句

1. 准备

   ```sql
   obclient> create table test.key_sub_parts_my_01(c1 char(10), c2 int, c3 date, c4 int) partition by key(c3 , c2) subpartition by key(c2, c1) subpartitions 8 partitions 8;

   obclient> create table test.hash_sub_part_my_01(c1 int, c2 int, c3 int) partition by hash(c1) subpartition by hash(c2) subpartitions 8 partitions 8;
   
   obclient> create table test.list_sub_parts_my_01(c1 int, c2 varchar(10), c3 date, c4 int)
            partition by list columns(c1, c2)
              subpartition by list columns(c2, c3) subpartition template(
              subpartition p0 values in('tiger', '1999-09-09'),
              subpartition p1 values in('tiger0', '2000-01-01'))(
              partition p0 values in (999, 'tiger0'),
              partition p1 values in (1999, 'tiger'));
   
   obclient> create table test.range_sub_parts_my_01(c1 int, c2 int, c3 int, c4 int) 
            partition by range columns(c1, c2) 
              subpartition by range columns (c2, c3) subpartition template(
              subpartition p0 values less than(111111, 11111),
              subpartition p1 values less than(222222, 22222),
              subpartition p2 values less than(333333, 33333),
              subpartition p3 values less than(maxvalue, maxvalue))(
              partition p0 values less than(11111,111111),
              partition p1 values less than(22222,222222),
              partition p2 values less than(33333,333333),
              partition p3 values less than(maxvalue, maxvalue));
   ```

2. 执行 explain route
   <!-- 这里为啥要执行这么多诊断命令 -->
   ```sql
   explain route select * from test.hash_sub_part_my_01 where c2=199912080 and c1=c2\G
   explain route select * from test.key_sub_parts_my_01 where c1=substr('I AM TIGER',3,5) and c3='2000-03-01' and c2=1245456\G
   explain route select * from test.list_sub_parts_my_01 where c3='1999-09-09' and c1=mod(1999,1000) and c2='tiger0'\G
   explain route select * from test.range_sub_parts_my_01 where c1=22222 and c2=111111 and c3=abcd\G
   ```

<!-- 3. 执行 `explain route` 命令，根据输出进行诊断。

   ```sql
   obclient> explain route select * from t0 where c1=abs(-1)\G
   ```

   输出如下，PARTITION_ID_CALC_DONE 诊断点返回 ret = -5055（OB_ERR_FUNCTION_UNKNOWN），且 partitions 值为 `(p-1)` 表明分区无法计算，结合 ODP 代码推测不支持 abs 函数。

   ```sql
   *************************** 1. row ***************************
   Route Plan: Trx Cur SQL:
   -----------------
   > SQL_PARSE:{sql_cmd:"COM_QUERY", sql:"explain route select * from t0 where c1=abs(-1)", table:"t0"};
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP", in_transaction:"false"};
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase", need_partition_location_lookup:true};
     > TABLE_ENTRY_LOOKUP:{table:"t0", table_id:1099511677778, part_num:8, table_type:"USER TABLE", entry_state:"AVAIL", entry_from_remote:false, has_dup_replica:false, is_lookup_succ:true};
     > PARTITION_ID_CALC_DONE:{ret:-5055, part_level:1, partitions:"(p-1)", parse_sql:"explain route select * from t0 where c1=abs(-1)"};
   > ROUTE_POLICY:{consistency_level:"STRONG", route_policy:"MERGE_IDC_ORDER", chosen_route_type:"ROUTE_TYPE_NONPARTITION_UNMERGE_LOCAL"};
   > CONGESTION_CONTROL:{force_retry_congested:"false", need_congestion_lookup:"true", lookup_success:"true", entry_exist:"true"};
   ``` -->

### PS 语句

1. 准备

   ```sql
   obclient> create table test.key_sub_parts_my_01(c1 char(10), c2 int, c3 date, c4 int) partition by key(c3 , c2) subpartition by key(c2, c1) subpartitions 8 partitions 8;

   obclient> create table test.hash_sub_part_my_01(c1 int, c2 int, c3 int) partition by hash(c1) subpartition by hash(c2) subpartitions 8 partitions 8;
   
   obclient> create table test.list_sub_parts_my_01(c1 int, c2 varchar(10), c3 date, c4 int)
            partition by list columns(c1, c2)
              subpartition by list columns(c2, c3) subpartition template(
              subpartition p0 values in('tiger', '1999-09-09'),
              subpartition p1 values in('tiger0', '2000-01-01'))(
              partition p0 values in (999, 'tiger0'),
              partition p1 values in (1999, 'tiger'));
   
   obclient> create table test.range_sub_parts_my_01(c1 int, c2 int, c3 int, c4 int) 
            partition by range columns(c1, c2) 
              subpartition by range columns (c2, c3) subpartition template(
              subpartition p0 values less than(111111, 11111),
              subpartition p1 values less than(222222, 22222),
              subpartition p2 values less than(333333, 33333),
              subpartition p3 values less than(maxvalue, maxvalue))(
              partition p0 values less than(11111,111111),
              partition p1 values less than(22222,222222),
              partition p2 values less than(33333,333333),
              partition p3 values less than(maxvalue, maxvalue));
   ```

2. 执行 explain route
   <!-- 判断前缀 -->
   ```sql
   obclient> prepare stmt0 from "select * from test.hash_sub_part_my_01 where c1=? and c2=?";
   obclient> set @c1=1999;
   obclient> set @c2=2999;
   obclient> explain route execute stmt0 using @c1,@c2;
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route execute stmt0 using @c1,@c2"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to partition server or ldc
   > TABLE_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   > PARTITION_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"hash_sub_part_my_01"}
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"hash_sub_part_my_01", table_id:1099511677777, partition_num:64, table_type:"USER TABLE", entry_from_remote:false}
     > PARTITION_ID_CALC_START:{}
       > EXPR_PARSE:{col_val:[[0]["", "?"], [1]["c2", "?"]]}
       > RESOLVE_EXPR:{part_range:"[1999 ; 1999]", sub_part_range:"[2999 ; 2999]"}
         > RESOLVE_TOKEN:{resolve:{"VARCHAR":"1999", collation:"utf8mb4_general_ci"}, token_type:"TOKEN_PLACE_HOLDER"}
         > RESOLVE_TOKEN:{resolve:{"VARCHAR":"2999", collation:"utf8mb4_general_ci"}, token_type:"TOKEN_PLACE_HOLDER"}
       > CALC_PARTITION_ID:{part_desc:{part_type:"hash", is_oracle_mode:false, part_num:8, part_space:0, part_level:1, part_func_type:"HASH_V2", obj_types:[[0]"INT"], cs_types:[[0]"binary"]}, sub_part_desc:{part_type:"hash", is_oracle_mode:false, part_num:8, part_space:0, part_level:1, part_func_type:"HASH_V2", obj_types:[[0]"INT"], cs_types:[[0]"binary"]}}
     > PARTITION_ID_CALC_DONE:{partition_id:1152921534940053511, level:2, partitions:"(p7sp7)", parse_sql:"prepare stmt0 from "select * from test.hash_sub_part_my_01 where c1=? and c2=?""}
     > PARTITION_ENTRY_LOOKUP_DONE:{leader:"10.10.10.2:50109", entry_from_remote:false}
   > LDC_ROUTE:{chosen_route_type:"ROUTE_TYPE_LEADER"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.2:50109"}
   
   1 row in set 
   ```

## 示例三：指定 IP 路由

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>通过配置项或注释指定 IP 路由，诊断结果是一样的，本示例通过配置项指定 IP 路由。</p>
</main>

1. 准备

   ```sql
   obclient> alter proxyconfig set target_db_server = '127.0.0.1:2993,127.0.0.1:2994;10.10.10.2:50109';
   ```

2. 执行 explain route

   ```sql
   obclient> explain route select 888\G
   ```

   输出如下。

   ```sql
   **************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route select 888"
   
   Route Prompts
   -----------------
   > SQL_PARSE
     [INFO] Can not get location cache of the query table
   > ROUTE_INFO
     [INFO] Will route target db server and loopback addr (127.0.0.1:2994) wouldn't do congestion control
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:""}
   > ROUTE_INFO:{route_info_type:"USE_CONFIG_TARGET_DB", svr_addr:"127.0.0.1:2994"}
   
   1 row in set
   ```

3. 直接执行 SQL 语句，查看 `obproxy_diagnose.log` 日志输出

   ```shell
   [2023-08-15 19:00:58.090319] [3281][Y0-00007F9BFEEA74E0] [ROUTE]((*route_diagnosis=
   Trans Current Query:"select 888"
   
   Route Prompts
   > SQL_PARSE
     [INFO] Can not get location cache of the query table
   > ROUTE_INFO
     [INFO] Will route target db server and loopback addr (127.0.0.1:2993) wouldn't do congestion control
   > CONGESTION_CONTROL
     [INFO] This replica(127.0.0.1:2993) is no need to pass congestion control
   > CONGESTION_CONTROL
     [INFO] This replica(127.0.0.1:2994) is no need to pass congestion control
   
   
   Route Plan
   > SQL_PARSE:{cmd:"COM_QUERY", table:""}
   > ROUTE_INFO:{route_info_type:"USE_CONFIG_TARGET_DB", svr_addr:"127.0.0.1:2993"}
   > CONGESTION_CONTROL:{svr_addr:"127.0.0.1:2993", need_congestion_lookup:false}
   > HANDLE_RESPONSE:{is_parititon_hit:"false", state:"CONNECT_ERROR"}
   > RETRY:{attempts:2, retry_status:"FOUND_EXISTING_ADDR", retry_type:"CONF_TARGET_DB_SERVER", retry_addr:{127.0.0.1:2994}}
   > CONGESTION_CONTROL:{svr_addr:"127.0.0.1:2994", need_congestion_lookup:false}
   > HANDLE_RESPONSE:{is_parititon_hit:"false", state:"CONNECT_ERROR"}
   > RETRY:{attempts:3, retry_status:"FOUND_EXISTING_ADDR", retry_type:"CONF_TARGET_DB_SERVER", retry_addr:{10.10.10.2:50109}}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.2:50109"}
   > HANDLE_RESPONSE:{is_parititon_hit:"false", state:"CONNECTION_ALIVE"}
   ```

## 示例四：指定分区名路由

1. 准备
   <!-- 前缀是否正确 -->
   ```sql
   obclient> create table t0(c1 int) partition by key(c1) partitions 8;
   obclient> create table t1(c1 int, c2 int) 
            partition by range(c1) 
              subpartition by range(c2) subpartition template(
              subpartition sp0 values less than(100),
              subpartition sp1 values less than(200),
              subpartition sp2 values less than(300),
              subpartition sp3 values less than(maxvalue))(
                partition p0 values less than(100),
                partition p1 values less than(200),
                partition p2 values less than(300),
                partition p3 values less than(maxvalue));
   ```

2. 执行 explain route

   ```sql
   obclient> explain route select * from t0 partition(p1) where c1=123\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route select * from t0 partition(p1) where c1=123"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to partition server or ldc
   > TABLE_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   > PARTITION_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"t0", table_id:1099511677777, partition_num:8, table_type:"USER TABLE"}
     > PARTITION_ID_CALC_DONE:{partition_id:1, part_name:"p1", level:1, partitions:"(p-1)"}
     > PARTITION_ENTRY_LOOKUP_DONE:{leader:"10.10.10.2:50109", partition_id:1, entry_from_remote:false}
   > ROUTE_POLICY:{chosen_route_type:"ROUTE_TYPE_LEADER"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.2:50109"}
   
   1 row in set (0.00 sec)
   <!-- 这里为什么还会再执行一个诊断命令呀 -->
   obclient> explain route insert into t1 partition(p0ssp2) values(150, 350)\G
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route insert into t1 partition(p0ssp2) values(150, 350)"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to partition server or ldc
   > TABLE_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   > PARTITION_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t1"}
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"t1", table_id:1099511677778, partition_num:16, table_type:"USER TABLE", entry_from_remote:false}
     > PARTITION_ID_CALC_DONE:{partition_id:1152921504875282434, part_name:"p0ssp2", level:2, partitions:"(p-1sp-1)"}
     > PARTITION_ENTRY_LOOKUP_DONE:{leader:"10.10.10.2:50109", partition_id:1152921504875282434, entry_from_remote:false}
   > ROUTE_POILCY:{chosen_route_type:"ROUTE_TYPE_LEADER"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.2:50109"}
   
   1 row in set (0.00 sec)
   ```

## 示例五：全局索引表路由

1. 准备

   ```sql
   obclient> alter proxyconfig set server_routing_mode='oceanbase';
   obclient> alter proxyconfig set proxy_primary_zone_name='';
   obclient> alter proxyconfig set enable_reroute=true;
   obclient> alter proxyconfig set enable_index_route = true;
   obclient> create table t0(c1 int, c2 int) partition by key(c1) partitions 8;
   obclient> create index t0_index on t0(c2) global partition by range(c2)  (partition p0 values less than (100), partition p1 values less than (200), partition p2 values less than (300));
   obclient> select * from t0 where c2=150;
   obclient> select * from t0 where c2=150;
   ```

   首次执行 `select * from t0 where c2=150;` 不会使用全局索引表，再次执行 `select * from t0 where c2=150;` 将使用全局索引表。

2. 查看日志执行结果

   因为该功能依赖 SQL 字面值，使用 explain route 将不会发往 OBServer 节点，就不会触发全局索引表 Cache 的创建，所以此处选择执行 SQL 后查看日志。

   ```shell
   $ grep "2023-08-15 14:24:33.262440" obproxy_diagnosis.log | sed "s/\/n/\n/g"
   ```

   输出如下。

   ```sql
   [2023-08-15 14:24:33.262440] [50970][Y0-00007F03ABDFA4E0] [ROUTE]((*route_diagnosis=
   Trans Current Query:"select * from t0 where c2=150"
   
   Route Prompts
   > ROUTE_INFO
     [INFO] Will use global index table name as real table name to route
   > HANDLE_RESPONSE
     [WARN] Will generate remote plan since not hit the partition
   
   
   Route Plan
   > SQL_PARSE:{cmd:"COM_QUERY", table:"__idx_500006_t0_index"}
   > ROUTE_INFO:{route_info_type:"USE_INDEX"}
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
     > TABLE_ENTRY_LOOKUP_START:{}
       > FETCH_TABLE_RELATED_DATA:{part_level:1, part_expr:[[0]"c2"]}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"__idx_500006_t0_index", table_id:500018, partition_num:3, table_type:"USER INDEX"}
     > PARTITION_ID_CALC_START:{}
       > EXPR_PARSE:{col_val:[[0]["c2", "150"]]}
       > RESOLVE_EXPR:{part_range:"[150 ; 150]"}
         > RESOLVE_TOKEN:{resolve_obj:{"BIGINT":150}, token_type:"TOKEN_INT_VAL", token:"150"}
       > CALC_PARTITION_ID:{part_desc:{part_type:"range", part_array_size:3, part_func_type:"RANGE", "part_array":[{high_bound_val:{"BIGINT":100}, is_max_value:false, part_id:500015, first_part_id:0}, {high_bound_val:{"BIGINT":200}, is_max_value:false, part_id:500016, first_part_id:0}, {high_bound_val:{"BIGINT":300}, is_max_value:false, part_id:500017, first_part_id:0}]}, sub_part_desc:""}
     > PARTITION_ID_CALC_DONE:{partition_id: xxx, partition_level:1, partitions:"(p1)", }
     > PARTITION_ENTRY_LOOKUP_DONE:{leader:{server:"10.10.10.2:50109", is_dup_replica:false, role:"LEADER", type:"FULL"}, partition_id:1152921504606846978, entry_from_remote:true}
   > ROUTE_POILCY:{chosen_route_type:"ROUTE_TYPE_LEADER"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.2:50109"}
   > HANDLE_RESPONSE:{is_parititon_hit:"false", state:"CONNECTION_ALIVE"}
   ```

## 示例六：分布式事务路由

1. 准备
   <!-- 前缀是否正确 -->
   ```sql
   obclient> alter proxyconfig set enable_ob_protocol_v2 = true;
   obclient> alter proxyconfig set enable_transaction_internal_routing = true;
   obclient> create table trans(c1 int) partition by hash(c1) partitions 8;
   obclient> begin;
   obclient> insert into trans values(10);
   ```

2. 执行 explain route

   ```sql
   obclient> obclient> explain route select * from trans where c1=20\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans First Query:"insert into trans values(10)"
   Trans Current Query:"explain route select * from trans where c1=20"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to transaction coordinator since current query couldn't be free routed
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"trans"}
   > ROUTE_INFO:{route_info_type:"USE_COODINATOR_SESSION", svr_addr:"10.10.10.2:50109", in_transaction:true}
   
   1 row in set (0.00 sec)
   ```

## 示例七：复用会话路由

### 会话级临时表强制路由

1. 准备，开启强制路由

   ```sql
   obclient> create temporary table t0(c1 int);
   obclient> select * from t0 where c1=123456;
   ```

2. 执行 explain route

   ```sql
   obclient> obclient> explain route insert into t0 values(1)\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route insert into t0 values(1)"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to last connected server
     [INFO] Query for session temporary table
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
   > ROUTE_INFO:{route_info_type:"USE_LAST_SESSION", svr_addr:"10.10.10.2:50109", trans_specified:true}
   
   1 row in set
   ```

### 普通事务路由

1. 准备，开启普通事务

   ```sql
   obclient> alter proxyconfig set enable_transaction_internal_routing = false;
   obclient> create table t0(c1 int) partition by hash(c1) partitions 8;
   <!-- 这里前缀正确不 -->
   obclient> begin;
   obclient> select * from t0 where c1=0;
   ```

2. 执行 explain route

   ```sql
   obclient> obclient> explain route insert into t0 values(4)\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans First Query:"select * from t0 where c1=0"
   Trans Current Query:"explain route insert into t0 values(4)"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to last connected server since current query in transaction
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
   > ROUTE_INFO:{route_info_type:"USE_LAST_SESSION", svr_addr:"10.10.10.1:50111", in_transaction:true}
   
   1 row in set
   ```

### 无法计算路由且 enable_cached_server = true

1. 准备

   ```sql
   obclient> alter proxyconfig set enable_cached_server = true;
   obclient> create table t0(c1 int) partition by hash(c1) partitions 8;
   ```

2. 执行 explain route

   ```sql
   obclient> explain route select * from t0 where c1=substr(c1, 2)\G
   ```

   输出如下。

   ```sql
   *************************** 1. row ***************************
   Route Plan:
   Trans Current Query:"explain route select * from t0 where c1=substr(c1, 2)"
   
   Route Prompts
   -----------------
   > ROUTE_INFO
     [INFO] Will route to partition server or ldc
   > TABLE_ENTRY_LOOKUP_DONE
     [INFO] Entry maybe expired since it got from proxy local cache
   > RESOLVE_TOKEN
     [WARN] Not support expr func(OB_PROXY_EXPR_TYPE_NONE)
   
   
   Route Plan
   -----------------
   > SQL_PARSE:{cmd:"COM_QUERY", table:"t0"}
   > ROUTE_INFO:{route_info_type:"USE_PARTITION_LOCATION_LOOKUP"}
   > LOCATION_CACHE_LOOKUP:{mode:"oceanbase"}
     > TABLE_ENTRY_LOOKUP_DONE:{table:"t0", table_id:1099511677779, partition_num:8, table_type:"USER TABLE", entry_from_remote:false}
     > PARTITION_ID_CALC_START:{}
       > EXPR_PARSE:{col_val:[[0]["c1", "substr"]]}
       > RESOLVE_EXPR:{error:-4002, part_range:"(MIN ; MAX)always true"}
         > RESOLVE_TOKEN:{error:-4002, resolve_obj:"null", token_type:"TOKEN_FUNC", token:"substr"}
     > PARTITION_ID_CALC_DONE:{error:-4002, partition_id:-1, level:1, partitions:"(p-1)"}
   > ROUTE_INFO:{route_info_type:"USE_CACHED_SESSION", svr_addr:"10.10.10.1:50111"}
   > CONGESTION_CONTROL:{svr_addr:"10.10.10.1:50111"}
   
   1 row in set
   ```
